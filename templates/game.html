{% extends "basic.html" %}

{% block content %}

<div class="game-info" style="text-align: center; margin-bottom: 10px;">
    <div class="score-panel">
        <span id="score" style="margin-right: 20px;">Wynik: 0</span>
        <span id="lives">Życia: 3</span>
    </div>
</div>

<div class="game-area" style="display: flex; justify-content: center; flex-direction: column; align-items: center;">
    <canvas width="750" height="585" id="game" style="background: black;"></canvas>

    <div id="gameStatus" style="margin-top: 15px;">
        <div id="gameOverMessage" style="display: none; color: red; font-weight: bold; font-size: 20px;">
            KONIEC GRY!
        </div>
        </div>

    <form id="scoreForm" method="post" action="{% url 'api_save_score' %}" style="display: none;">
        {% csrf_token %}
        <input type="hidden" name="score" id="finalScoreInput">
        <button type="submit" id="submitScoreBtn" class="btn btn-primary">Zapisz Wynik w Rankingu</button>
    </form>
</div>

<script>
// --- GRA ---
const canvas = document.getElementById('game');
const context = canvas.getContext('2d');
const grid = 15;
const paddleHeight = grid * 5;
const maxPaddleY = canvas.height - grid - paddleHeight;

// --- ZMIENNE KONFIGURACYJNE ---
var basePaddleSpeed = 6;
var baseBallSpeed = 5;
const botSpeed = 8; // Prędkość bota (Idealny)

// --- ZMIENNE STANU GRY ---
let score = 0;
let lives = 3;
let gameRunning = false;
let gameStarted = false;

// --- OBIEKTY GRY ---
const playerPaddle = {
  x: grid * 2,
  y: canvas.height / 2 - paddleHeight / 2,
  width: grid,
  height: paddleHeight,
  dy: 0,
  speed: basePaddleSpeed
};

const botPaddle = {
  x: canvas.width - grid * 3,
  y: canvas.height / 2 - paddleHeight / 2,
  width: grid,
  height: paddleHeight,
  speed: botSpeed
};

const ball = {
  x: canvas.width / 2,
  y: canvas.height / 2,
  width: grid,
  height: grid,
  resetting: false,
  dx: baseBallSpeed,
  dy: baseBallSpeed
};

// --- FUNKCJE POMOCNICZE I STATUS ---

function drawStatus() {
  // Rysowanie statusu jest teraz przeniesione poza canvas, do HTML
  // Wewnątrz canvas rysujemy tylko, jeśli gra jest zatrzymana

  // Aktualizacja HTML
  document.getElementById('score').innerText = `Wynik: ${score}`;
  document.getElementById('lives').innerText = `Życia: ${lives}`;

  if (!gameRunning && gameStarted) {
    context.textAlign = 'center';
    context.fillStyle = 'red';
    context.font = '36px Arial';
    context.fillText('KONIEC GRY!', canvas.width / 2, canvas.height / 2 - 40);
    context.font = '24px Arial';
    context.fillText(`Ostateczny wynik: ${score}`, canvas.width / 2, canvas.height / 2);
    // Komunikat o zapisie jest teraz w HTML pod canvas
  } else if (!gameRunning && !gameStarted) {
    context.textAlign = 'center';
    context.fillStyle = 'white';
    context.font = '24px Arial';
    context.fillText('Wciśnij SPACJĘ, aby rozpocząć!', canvas.width / 2, canvas.height / 2);
  }
}

function gameOver() {
  gameRunning = false;

  const finalScoreInput = document.getElementById('finalScoreInput');
  const scoreForm = document.getElementById('scoreForm');

  if (finalScoreInput) {
      finalScoreInput.value = score;
  }
  if (scoreForm) scoreForm.style.display = 'block';
}

function resetBall(loseLife = false) {
  if (loseLife) {
    lives--;
  }

  if (lives <= 0) {
    return gameOver();
  }

  ball.x = canvas.width / 2;
  ball.y = canvas.height / 2;

  ball.dx = baseBallSpeed * (Math.random() > 0.5 ? 1 : -1);
  ball.dy = baseBallSpeed * (Math.random() > 0.5 ? 1 : -1);

  ball.resetting = true;

  setTimeout(() => {
      ball.resetting = false;
  }, 400);
}

function collides(obj1, obj2) {
  return obj1.x < obj2.x + obj2.width &&
         obj1.x + obj1.width > obj2.x &&
         obj1.y < obj2.y + obj2.height &&
         obj1.y + obj1.height > obj2.y;
}


// --- LOGIKA RUCHU BOTA (Idealny Bot) ---
function moveBotPaddle() {
    const targetY = ball.y - botPaddle.height / 2 + (ball.width / 2);
    const currentY = botPaddle.y;
    const deltaY = targetY - currentY;

    if (Math.abs(deltaY) > 5) {
        // Wykorzystujemy większą prędkość do idealnego śledzenia
        const effectiveSpeed = botPaddle.speed + 15;

        const moveAmount = Math.min(Math.abs(deltaY), effectiveSpeed);
        const direction = Math.sign(deltaY);

        botPaddle.y += moveAmount * direction;
    }

    if (botPaddle.y < grid) {
      botPaddle.y = grid;
    } else if (botPaddle.y > maxPaddleY) {
      botPaddle.y = maxPaddleY;
    }
}

// Ruch piłki i kolizje
function moveBall() {
  ball.x += ball.dx;
  ball.y += ball.dy;

  // Odbicie od górnej i dolnej ściany
  if (ball.y < grid) {
    ball.y = grid;
    ball.dy *= -1;
  }
  else if (ball.y + grid > canvas.height - grid) {
    ball.y = canvas.height - grid * 2;
    ball.dy *= -1;
  }

  // UTRATA ŻYCIA: Piłka wypada poza krawędź gracza (lewa strona)
  if (ball.x < 0) {
    resetBall(true);
  }
  // Piłka wypada poza krawędź bota (prawa strona)
  else if (ball.x + grid > canvas.width) {
    resetBall(false); // Bot jest idealny, nie traci życia
  }

  // Sprawdzenie kolizji z paletką GRACZA (Lewa)
  if (collides(ball, playerPaddle)) {
    ball.dx *= -1;
    ball.x = playerPaddle.x + playerPaddle.width;
    score++;

    // ZWIĘKSZENIE PRĘDKOŚCI CO 5 PUNKTÓW
    if (score > 0 && score % 5 === 0 && Math.abs(ball.dx) < 20) {
        ball.dx += Math.sign(ball.dx) * 1;
        ball.dy += Math.sign(ball.dy) * 1;
        // baseBallSpeed++; // Nie musimy resetować bazowej
    }
  }
  // Sprawdzenie kolizji z paletką BOTA (Prawa)
  else if (collides(ball, botPaddle)) {
    ball.dx *= -1;
    ball.x = botPaddle.x - ball.width;
  }
}

// --- GŁÓWNA PĘTLA GRY ---

function loop() {
  requestAnimationFrame(loop);

  context.clearRect(0,0,canvas.width,canvas.height);

  // Zawsze rysujemy tło i status, nawet jeśli gra jest zatrzymana
  drawStatus();

  if (gameRunning) {
    // Ruch paletek
    playerPaddle.y += playerPaddle.dy;
    moveBotPaddle();

    // Zapobieganie przechodzeniu przez ściany (Gracz)
    if (playerPaddle.y < grid) {
      playerPaddle.y = grid;
    }
    else if (playerPaddle.y > maxPaddleY) {
      playerPaddle.y = maxPaddleY;
    }

    // Ruch piłki i kolizje
    moveBall();

    // Rysowanie paletek i piłki
    context.fillStyle = 'white';
    context.fillRect(playerPaddle.x, playerPaddle.y, playerPaddle.width, playerPaddle.height);
    context.fillRect(botPaddle.x, botPaddle.y, botPaddle.width, botPaddle.height);
    context.fillRect(ball.x, ball.y, ball.width, ball.height);
  }

  // Rysowanie ścian i linii środkowej
  context.fillStyle = 'lightgrey';
  context.fillRect(0, 0, canvas.width, grid);
  context.fillRect(0, canvas.height - grid, canvas.width, grid);
  for (let i = grid; i < canvas.height - grid; i += grid * 2) {
    context.fillRect(canvas.width / 2 - grid / 2, i, grid, grid);
  }
}


// --- OBSŁUGA KLAWIATURY (GRACZ KONTROLUJE LEWĄ PALETKĘ) ---
document.addEventListener('keydown', function(e) {
  // Klawisz SPACJI (dla startu/restartu)
  if (e.which === 32 && !gameRunning) {
    score = 0;
    lives = 3;
    baseBallSpeed = 5;
    gameRunning = true;
    gameStarted = true;

    // Ukryj formularz zapisu
    const scoreForm = document.getElementById('scoreForm');
    if (scoreForm) scoreForm.style.display = 'none';

    resetBall(false);
  }

  // GRACZ (Lewa paletka) - W i S
  if (e.which === 87) { // W (Góra)
    playerPaddle.dy = -playerPaddle.speed;
  }
  else if (e.which === 83) { // S (Dół)
    playerPaddle.dy = playerPaddle.speed;
  }
});

document.addEventListener('keyup', function(e) {
  // Zatrzymanie ruchu
  if (e.which === 87 || e.which === 83) {
    playerPaddle.dy = 0;
  }
});

// START GRY (wywołanie głównej pętli)
requestAnimationFrame(loop);
</script>
{% endblock content %}